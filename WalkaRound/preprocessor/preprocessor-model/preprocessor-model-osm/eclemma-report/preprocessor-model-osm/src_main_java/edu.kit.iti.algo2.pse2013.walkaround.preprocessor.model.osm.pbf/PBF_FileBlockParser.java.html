<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>PBF_FileBlockParser.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">preprocessor-model-osm (16.08.2013 10:01:17)</a> &gt; <a href="../../index.html" class="el_group">preprocessor-model-osm</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.html" class="el_package">edu.kit.iti.algo2.pse2013.walkaround.preprocessor.model.osm.pbf</a> &gt; <span class="el_source">PBF_FileBlockParser.java</span></div><h1>PBF_FileBlockParser.java</h1><pre class="source lang-java linenums">package edu.kit.iti.algo2.pse2013.walkaround.preprocessor.model.osm.pbf;

import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.logging.Logger;

import crosby.binary.BinaryParser;
import crosby.binary.Osmformat;
import crosby.binary.Osmformat.DenseNodes;
import crosby.binary.Osmformat.HeaderBlock;
import crosby.binary.Osmformat.Node;
import crosby.binary.Osmformat.PrimitiveGroup;
import crosby.binary.Osmformat.Relation;
import crosby.binary.Osmformat.Way;
import crosby.binary.file.BlockReaderAdapter;
import crosby.binary.file.FileBlockPosition;
import edu.kit.iti.algo2.pse2013.walkaround.preprocessor.model.osm.mapdata.OSMNode;
import edu.kit.iti.algo2.pse2013.walkaround.preprocessor.model.osm.mapdata.OSMWay;
import edu.kit.iti.algo2.pse2013.walkaround.preprocessor.model.osm.mapdata.category.OSMCategory;
import edu.kit.iti.algo2.pse2013.walkaround.preprocessor.model.osm.mapdata.category.OSMCategoryFactory;
import edu.kit.iti.algo2.pse2013.walkaround.shared.datastructures.LocationDataIO;
import edu.kit.iti.algo2.pse2013.walkaround.shared.datastructures.POI;
import edu.kit.iti.algo2.pse2013.walkaround.shared.graph.GraphDataIO;

public class PBF_FileBlockParser extends BinaryParser implements BlockReaderAdapter {
	/**
	 * In this state all nodes that are part of a way are added to {@link this#interestingNodes}.
	 */
	private static final short STATE_FIND_NODES_FOR_WAYS = 0;
	/**
	 * In this state all nodes in {@link this#interestingNodes} are filled with content (lat, lon and the tags).
	 * Then the ways are added to the object {@link this#graphData}.
	 */
	private static final short STATE_PARSE_WAYS = 1;
	/**
	 * Now the {@link this#interestingNodes} are cleared.
	 * All punctiform POIs are being added to {@link this#locationData}.
	 * All nodes, that are part of extensive POIs are being added to {@link this#interestingNodes}.
	 */
	private static final short STATE_FIND_NODES_FOR_POIS = 2;
	/**
	 * The nodes in {@link this#interestingNodes} are being filled with content (lat, lon and the tags).
	 * Then the POI-ways, these nodes are part of, are being added to {@link this#locationData}.
	 */
	private static final short STATE_PARSE_POIS = 3;
	/**
	 * This state marks, that no further run is necessary
	 */
	private static final short STATE_FINISH = 4;

<span class="fc" id="L53">	private Map&lt;Long, OSMNode&gt; interestingNodes = new TreeMap&lt;Long, OSMNode&gt;();</span>

<span class="fc" id="L55">	private static final Logger logger = Logger.getLogger(PBF_FileBlockParser.class.getSimpleName());</span>

	private GraphDataIO graphData;
	private LocationDataIO locationData;

<span class="fc" id="L60">	private short state = STATE_FIND_NODES_FOR_WAYS;</span>
<span class="fc" id="L61">	private static int readBlocks = 0;</span>

<span class="fc" id="L63">	public PBF_FileBlockParser(GraphDataIO graphData, LocationDataIO locationData) {</span>
<span class="fc" id="L64">		this.graphData = graphData;</span>
<span class="fc" id="L65">		this.locationData = locationData;</span>
<span class="fc" id="L66">	}</span>

	@Override
	public void complete() {
<span class="fc" id="L70">		System.out.println();</span>
<span class="fc" id="L71">		readBlocks = 0;</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">		if (state == STATE_FIND_NODES_FOR_WAYS) {</span>
<span class="fc" id="L73">			logger.info(String.format(&quot;Finished first run\n\t%d interesting nodes for ways found.&quot;, interestingNodes.size()));</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">		} else if (state == STATE_PARSE_WAYS) {</span>
<span class="fc" id="L75">			logger.info(String.format(&quot;Finished second run:\n\t%d Edges found.&quot;, graphData.getEdges().size()));</span>
<span class="fc" id="L76">			interestingNodes.clear();</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">		} else if (state == STATE_FIND_NODES_FOR_POIS) {</span>
<span class="fc" id="L78">			logger.info(String.format(&quot;Finished third run:\n\t%d interesting nodes for POIs found.\n\t%d POIs found.&quot;, interestingNodes.size(), locationData.getPOIs().size()));</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">		} else if (state == STATE_PARSE_POIS) {</span>
<span class="fc" id="L80">			logger.info(String.format(&quot;Finished fourth run:\n\tAdded extensive POIs. Now %d POIs in total.&quot;, locationData.getPOIs().size()));</span>
		}
<span class="fc" id="L82">		state++;</span>
<span class="fc" id="L83">	}</span>
	public boolean skipBlock(FileBlockPosition blockPos) {
<span class="fc" id="L85">		return false;</span>
	}

	@Override
	protected void parse(HeaderBlock block) {
<span class="fc" id="L90">		logger.info(&quot;Started parsing of file:\n\tEach character represents roughly 8000 osm-elements.\n\t\t- D for DenseNodes\n\t\t- N for Nodes\n\t\t- W for Ways\n\t\t- R for Relations&quot;);</span>
<span class="fc" id="L91">	}</span>

	public void parse(Osmformat.PrimitiveBlock block) {
<span class="fc" id="L94">		super.parse(block);</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">		for (PrimitiveGroup group : block.getPrimitivegroupList()) {</span>
<span class="fc" id="L96">			readBlocks++;</span>
<span class="pc bpc" id="L97" title="1 of 4 branches missed.">			if (group.getDense() != null &amp;&amp; group.getDense().getIdCount() &gt;= 1) {</span>
<span class="fc" id="L98">				System.out.print('D');</span>
<span class="pc bpc" id="L99" title="2 of 4 branches missed.">			} else if (group.getNodesList() != null &amp;&amp; group.getNodesList().size() &gt;= 1) {</span>
<span class="nc" id="L100">				System.out.print('N');</span>
<span class="pc bpc" id="L101" title="1 of 4 branches missed.">			} else if (group.getWaysList() != null &amp;&amp; group.getWaysList().size() &gt;= 1) {</span>
<span class="fc" id="L102">				System.out.print('W');</span>
<span class="pc bpc" id="L103" title="2 of 4 branches missed.">			} else if (group.getRelationsList() != null &amp;&amp; group.getRelationsList().size() &gt;= 1) {</span>
<span class="fc" id="L104">				System.out.print('R');</span>
<span class="fc" id="L105">			} else {</span>
<span class="nc" id="L106">				readBlocks--;</span>
			}
<span class="fc bfc" id="L108" title="All 2 branches covered.">			if (readBlocks % 50 == 0) {</span>
<span class="fc" id="L109">				System.out.println();</span>
			}
		}
<span class="fc" id="L112">	}</span>

	@Override
	protected void parseDense(DenseNodes dNodes) {
<span class="fc bfc" id="L116" title="All 6 branches covered.">		if (state == STATE_PARSE_WAYS || state == STATE_PARSE_POIS || state == STATE_FIND_NODES_FOR_POIS) {</span>
<span class="fc" id="L117">			List&lt;Long&gt; ids = dNodes.getIdList();</span>
<span class="fc" id="L118">			long id = 0;</span>
<span class="fc" id="L119">			long lat = 0;</span>
<span class="fc" id="L120">			long lon = 0;</span>
<span class="fc" id="L121">			Iterator&lt;Integer&gt; keysVals = dNodes.getKeysValsList().iterator();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">			for (int i = 0; i &lt; ids.size(); i++) {</span>
<span class="fc" id="L123">				id += ids.get(i);</span>
<span class="fc" id="L124">				lat += dNodes.getLat(i);</span>
<span class="fc" id="L125">				lon += dNodes.getLon(i);</span>

				OSMNode currentNode;
<span class="fc bfc" id="L128" title="All 2 branches covered.">				if (interestingNodes.containsKey(id)) {</span>
<span class="fc" id="L129">					currentNode = interestingNodes.get(id);</span>
<span class="fc" id="L130">				} else {</span>
<span class="fc" id="L131">					currentNode = new OSMNode(id);</span>
				}
<span class="fc" id="L133">				currentNode.setLatitude(lat * granularity * .000000001);</span>
<span class="fc" id="L134">				currentNode.setLongitude(lon * granularity * .000000001);</span>

				int j;
<span class="pc bpc" id="L137" title="2 of 6 branches missed.">				while (keysVals.hasNext() &amp;&amp; (j = keysVals.next()) != 0 &amp;&amp; keysVals.hasNext()) {</span>
<span class="fc" id="L138">					currentNode.addTag(getStringById(j), getStringById(keysVals.next()));</span>
				}
<span class="fc bfc" id="L140" title="All 2 branches covered.">				if (state == STATE_FIND_NODES_FOR_POIS) {</span>
<span class="fc" id="L141">					POI poi = currentNode.getPOI();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">					if (poi != null) {</span>
<span class="fc" id="L143">						locationData.addPOI(poi);</span>
					}
				}
			}
		}
<span class="fc" id="L148">	}</span>

	@Override
	protected void parseNodes(List&lt;Node&gt; inNodes) {
<span class="fc bfc" id="L152" title="All 6 branches covered.">		if (state == STATE_PARSE_WAYS || state == STATE_PARSE_POIS || state == STATE_FIND_NODES_FOR_POIS) {</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">			for (Node inNode : inNodes) {</span>
				OSMNode currentNode;
<span class="nc bnc" id="L155" title="All 2 branches missed.">				if (interestingNodes.containsKey(inNode.getId())) {</span>
<span class="nc" id="L156">					currentNode = interestingNodes.get(inNode.getId());</span>
<span class="nc" id="L157">				} else {</span>
<span class="nc" id="L158">					currentNode = new OSMNode(inNode.getId());</span>
				}
<span class="nc" id="L160">				currentNode.setLatitude(inNode.getLat() * granularity * .000000001);</span>
<span class="nc" id="L161">				currentNode.setLongitude(inNode.getLon() * granularity * .000000001);</span>

<span class="nc" id="L163">				List&lt;Integer&gt; keys = inNode.getKeysList();</span>
<span class="nc" id="L164">				List&lt;Integer&gt; vals = inNode.getValsList();</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">				for (int i = 0; i &lt; Math.min(keys.size(), vals.size()); i++) {</span>
<span class="nc" id="L166">					currentNode.addTag(getStringById(keys.get(i)), getStringById(vals.get(i)));</span>
				}
<span class="nc bnc" id="L168" title="All 2 branches missed.">				if (state == STATE_FIND_NODES_FOR_POIS) {</span>
<span class="nc" id="L169">					POI poi = currentNode.getPOI();</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">					if (poi != null) {</span>
<span class="nc" id="L171">						locationData.addPOI(poi);</span>
					}
				}
			}
		}
<span class="fc" id="L176">	}</span>

	@Override
	protected void parseRelations(List&lt;Relation&gt; inRelations) {
		//TODO: Implement
<span class="fc" id="L181">	}</span>

	@Override
	protected void parseWays(List&lt;Way&gt; inWays) {
<span class="fc bfc" id="L185" title="All 2 branches covered.">		for (Way w : inWays) {</span>
<span class="fc" id="L186">			OSMWay way = new OSMWay(w.getId());</span>
<span class="fc" id="L187">			List&lt;Long&gt; nodeRefs = w.getRefsList();</span>

<span class="pc bpc" id="L189" title="1 of 2 branches missed.">			if (nodeRefs != null) {</span>
<span class="fc" id="L190">				boolean isValidWay = true;</span>
<span class="fc" id="L191">				long ref = 0;</span>
<span class="fc bfc" id="L192" title="All 4 branches covered.">				for (int i = 0; i &lt; nodeRefs.size() &amp;&amp; isValidWay; i++) {</span>
<span class="fc" id="L193">					ref += nodeRefs.get(i);</span>
<span class="fc bfc" id="L194" title="All 4 branches covered.">					if (state == STATE_PARSE_WAYS || state == STATE_PARSE_POIS) {</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">						if (interestingNodes.containsKey(ref)) {</span>
<span class="fc" id="L196">							way.addNode(interestingNodes.get(ref));</span>
<span class="fc" id="L197">						} else {</span>
<span class="fc" id="L198">							isValidWay = false;</span>
						}
					}
				}
<span class="fc bfc" id="L202" title="All 2 branches covered.">				if (isValidWay) {</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">					for (int i = 0; i &lt; Math.min(w.getKeysCount(), w.getValsCount()); i++) {</span>
<span class="fc" id="L204">						way.addTag(getStringById(w.getKeys(i)), getStringById(w.getVals(i)));</span>
					}
<span class="fc" id="L206">					OSMCategory footCat = OSMCategoryFactory.createFootwayCategory();</span>
<span class="fc" id="L207">					OSMCategory allAreaCat = OSMCategoryFactory.createAllAreaCategory();</span>
<span class="fc" id="L208">					OSMCategory allPOICat = OSMCategoryFactory.createAllPOICategory();</span>
<span class="fc bfc" id="L209" title="All 4 branches covered.">					if (footCat.accepts(way) || allAreaCat.accepts(way)) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">						if (state == STATE_FIND_NODES_FOR_WAYS) {</span>
<span class="fc" id="L211">							long curID = 0;</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">							for (Long idDiff : w.getRefsList()) {</span>
<span class="fc" id="L213">								interestingNodes.put(curID += idDiff, new OSMNode(curID));</span>
							}
<span class="fc bfc" id="L215" title="All 2 branches covered.">						} else if (state == STATE_PARSE_WAYS){</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">							if (footCat.accepts(way)) {</span>
<span class="fc" id="L217">								graphData.addEdges(way.getEdges());</span>
							}
<span class="fc bfc" id="L219" title="All 2 branches covered.">							if (allAreaCat.accepts(way)) {</span>
<span class="fc" id="L220">								locationData.addArea(way.getArea());</span>
							}
						}
					}
<span class="fc bfc" id="L224" title="All 2 branches covered.">					if (allPOICat.accepts(way)) {</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">						if (state == STATE_PARSE_POIS) {</span>
<span class="fc" id="L226">							POI poi = way.getPOI();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">							if (poi != null) {</span>
<span class="fc" id="L228">								locationData.addPOI(poi);</span>
							}
<span class="fc bfc" id="L230" title="All 2 branches covered.">						} else if (state == STATE_FIND_NODES_FOR_POIS) {</span>
<span class="fc" id="L231">							long curID = 0;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">							for (Long idDiff : w.getRefsList()) {</span>
<span class="fc" id="L233">								interestingNodes.put(curID += idDiff, new OSMNode(curID));</span>
							}
						}
					}
				}
			}
		}
<span class="fc" id="L240">	}</span>
	public boolean needsFurtherRun() {
<span class="fc bfc" id="L242" title="All 2 branches covered.">		return state &lt; STATE_FINISH;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.3.201306030806</span>preprocessor-model-osm (16.08.2013 10:01:17)</div></body></html>