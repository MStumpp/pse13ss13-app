<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>TileFetcher.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">walkaround-tests (16.08.2013 02:31:21)</a> &gt; <a href="../../index.html" class="el_group">walkaround-tests</a> &gt; <a href="../index.html" class="el_bundle">app-src</a> &gt; <a href="index.html" class="el_package">edu.kit.iti.algo2.pse2013.walkaround.client.model.tile</a> &gt; <span class="el_source">TileFetcher.java</span></div><h1>TileFetcher.java</h1><pre class="source lang-java linenums">package edu.kit.iti.algo2.pse2013.walkaround.client.model.tile;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.LinkedList;
import java.util.Queue;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.preference.PreferenceManager;
import android.support.v4.util.LruCache;
import android.util.Log;
import edu.kit.iti.algo2.pse2013.walkaround.client.R;
import edu.kit.iti.algo2.pse2013.walkaround.client.model.util.TileUtility;
import edu.kit.iti.algo2.pse2013.walkaround.shared.datastructures.Coordinate;

/**
 * Testfälle kommen in {@code client-view}, da hier Android-Klassen verwendet werden.
 *
 * Diese Klasse implementiert einen Downloader für Karten-Kacheln, der eine Tile-Cache mit LRU-Ersetzungsstrategie
 * verwendet.
 * @author Florian Sch&amp;auml;fer
 */
<span class="fc" id="L28">public class TileFetcher {</span>
<span class="fc" id="L29">	private static final String TAG = TileFetcher.class.getSimpleName();</span>
<span class="fc" id="L30">	private static final int MAX_CACHE_SIZE = 500;</span>
<span class="fc" id="L31">	private LruCache&lt;String, Bitmap&gt; cache = new LruCache&lt;String, Bitmap&gt;(MAX_CACHE_SIZE);</span>
<span class="fc" id="L32">	private FetchingQueue currentRunnable = new FetchingQueue();</span>
<span class="fc" id="L33">	private Thread currentThread = new Thread(currentRunnable);</span>

	/**
	 * Downloads all tiles that are located inside the rectangular area which has the following parameters:
	 * &lt;ul&gt;
	 * &lt;li&gt;A geospatial coordinate {@code topLeft} from inside the upper- and leftmost tile in the requested rectangle&lt;/li&gt;
	 * &lt;li&gt;{@code numTilesX} columns of tiles&lt;/li&gt;
	 * &lt;li&gt;{@code numTilesY} rows of tiles&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * @param levelOfDetail the level of detail for all the downloaded tiles
	 * @param topLeft a coordinate, which lies inside the tile which marks the upper left corner of the requested rectangle
	 * @param numTilesX the number of tile-columns in the requested rectangle
	 * @param numTilesY the number of tile-rows in the requested rectangle
	 */
	public void requestTiles(final int levelOfDetail, final Coordinate topLeft, final Coordinate bottomRight, TileListener listener) {
		//Log.d(TAG, String.format(&quot;TileFetcher.requestTiles(%d, [%.4f|%.4f], %d, %d, %s)&quot;, levelOfDetail, topLeft.getLatitude(), topLeft.getLongitude(), numTilesX, numTilesY, listener));

		//Log.d(TAG, &quot;Convert GeoCoordinates into Tile-Indices.&quot;);
<span class="fc" id="L52">		final int[] startTileIndex = TileUtility.getXYTileIndex(topLeft, levelOfDetail);</span>
<span class="fc" id="L53">		final int[] endTileIndex = TileUtility.getXYTileIndex(bottomRight, levelOfDetail);</span>
		//Log.d(TAG, String.format(&quot;x: %d columns from %d on\ny: %d rows from %d on&quot;, numTilesX, startTileIndex[0], numTilesY, startTileIndex[1]));

<span class="fc" id="L56">		requestTiles(levelOfDetail, startTileIndex[0]- 1, startTileIndex[1] -1, endTileIndex[0] + 1, endTileIndex[1] + 1, listener);</span>
		//requestTiles(levelOfDetail, startTileIndex[0] - 1, startTileIndex[1] - 1, startTileIndex[0] + numTilesX + 1, startTileIndex[1] + numTilesY + 1, null);
<span class="fc" id="L58">	}</span>
	public void clearCache(){
<span class="nc" id="L60">		Log.d(TAG, &quot;Clearing cache...&quot;);</span>
<span class="nc" id="L61">		cache.evictAll();</span>
<span class="nc" id="L62">	}</span>

	public void requestTiles(final int levelOfDetail, final int minX, final int minY, final int maxX, final int maxY, TileListener listener) {
<span class="fc" id="L65">		Log.d(TAG, String.format(&quot;TileFetcher.requestTiles(%d, %d, %d, %d, %d, %s)&quot;, levelOfDetail, minX, minY, maxX, maxY, listener));</span>

<span class="fc" id="L67">		int minLevelOfDetail = CurrentMapStyleModel.getInstance().getCurrentMapStyle().getMinLevelOfDetail();</span>
<span class="fc" id="L68">		int maxLevelOfDetail = CurrentMapStyleModel.getInstance().getCurrentMapStyle().getMaxLevelOfDetail();</span>

<span class="fc" id="L70">		Log.d(TAG, String.format(&quot;Check for valid LoD (between %d and %d).&quot;, minLevelOfDetail, maxLevelOfDetail));</span>
<span class="pc bpc" id="L71" title="2 of 4 branches missed.">		if (maxLevelOfDetail &lt; levelOfDetail || minLevelOfDetail &gt; levelOfDetail) {</span>
<span class="nc" id="L72">			Log.d(TAG, &quot;LoD invalid! =&gt; Exiting =&gt; not sending back any tiles.&quot;);</span>
<span class="nc" id="L73">			throw new IllegalArgumentException(&quot;Level of detail is invalid!&quot;);</span>
		}
<span class="fc" id="L75">		Log.d(TAG, &quot;LoD valid!&quot;);</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">		if (listener != null) {</span>
<span class="fc" id="L77">			currentRunnable.clearQueue();</span>
<span class="fc" id="L78">			currentRunnable.setListener(listener);</span>
<span class="fc" id="L79">			Log.d(TAG, &quot;Cleared fetching-queue&quot;);</span>
		}


<span class="fc" id="L83">		int tileGridWidth = (int) Math.pow(2, levelOfDetail);</span>

<span class="fc bfc" id="L85" title="All 2 branches covered.">		for (int x = minX; x &lt;= maxX; x++) {</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">			for (int y = minY; y &lt;= maxY; y++) {</span>
<span class="fc" id="L87">				x = x % tileGridWidth;</span>
<span class="fc" id="L88">				y = y % tileGridWidth;</span>

<span class="fc" id="L90">				final String urlString = String.format(CurrentMapStyleModel.getInstance().getCurrentMapStyle().getTileURL(), x, y, levelOfDetail);</span>
				Bitmap bmpFromCache;

<span class="pc bpc" id="L93" title="1 of 2 branches missed.">				if ((bmpFromCache = cache.get(urlString)) != null) {</span>
<span class="nc" id="L94">					Log.d(TAG, String.format(&quot;Fetched tile from cache: %s (%s/%s/%s.png)&quot;, bmpFromCache, levelOfDetail, x, y));</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">					if (listener != null) {</span>
<span class="nc" id="L96">						listener.receiveTile(bmpFromCache, x, y, levelOfDetail);</span>
					}
<span class="nc" id="L98">				} else {</span>
<span class="fc" id="L99">					currentRunnable.offerQueue(urlString, x, y, levelOfDetail);</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">					if (!currentThread.isAlive()) {</span>
<span class="fc" id="L101">						currentThread = new Thread(currentRunnable);</span>
<span class="fc" id="L102">						currentThread.start();</span>
					}
				}
			}
		}
<span class="fc" id="L107">	}</span>


	private class FetchingQueue implements Runnable {
<span class="fc" id="L111">		private Queue&lt;String&gt; urlList = new LinkedList&lt;String&gt;();</span>
<span class="fc" id="L112">		private Queue&lt;Integer&gt; xList = new LinkedList&lt;Integer&gt;();</span>
<span class="fc" id="L113">		private Queue&lt;Integer&gt; yList = new LinkedList&lt;Integer&gt;();</span>
<span class="fc" id="L114">		private Queue&lt;Integer&gt; levelOfDetailList = new LinkedList&lt;Integer&gt;();</span>
		private TileListener listener;

<span class="fc" id="L117">		public FetchingQueue() { }</span>

		public void setListener(TileListener listener) {
<span class="fc" id="L120">			this.listener = listener;</span>
<span class="fc" id="L121">		}</span>

		public void offerQueue(String url, int x, int y, int levelOfDetail) {
<span class="fc" id="L124">			urlList.offer(url);</span>
<span class="fc" id="L125">			xList.offer(x);</span>
<span class="fc" id="L126">			yList.offer(y);</span>
<span class="fc" id="L127">			levelOfDetailList.offer(levelOfDetail);</span>
<span class="fc" id="L128">		}</span>
		public void clearQueue() {
<span class="fc" id="L130">			xList.clear();</span>
<span class="fc" id="L131">			yList.clear();</span>
<span class="fc" id="L132">			urlList.clear();</span>
<span class="fc" id="L133">			levelOfDetailList.clear();</span>
<span class="fc" id="L134">		}</span>

		public void run() {
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">			while(xList.size() &gt; 0) {</span>
<span class="fc" id="L138">				int x = xList.poll();</span>
<span class="fc" id="L139">				int y = yList.poll();</span>
<span class="fc" id="L140">				String urlString = urlList.poll();</span>
<span class="fc" id="L141">				int levelOfDetail = levelOfDetailList.poll();</span>

				try {
<span class="nc" id="L144">					URLConnection conn = new URL(urlString).openConnection();</span>
<span class="nc" id="L145">					conn.connect();</span>
<span class="nc" id="L146">					InputStream inStream = conn.getInputStream();</span>
<span class="nc" id="L147">					BufferedInputStream bis = new BufferedInputStream(inStream);</span>
<span class="nc" id="L148">					Bitmap result = BitmapFactory.decodeStream(bis);</span>
<span class="nc" id="L149">					bis.close();</span>
<span class="nc" id="L150">					inStream.close();</span>
<span class="nc" id="L151">					Log.d(TAG, String.format(&quot;Send to TileListener: %s (%s/%s/%s.png)&quot;, result, levelOfDetail, x, y));</span>
<span class="nc" id="L152">					listener.receiveTile(result, x, y, levelOfDetail);</span>
<span class="nc" id="L153">					cache.put(urlString, result);</span>
<span class="nc" id="L154">				} catch (MalformedURLException e) {</span>
<span class="nc" id="L155">					Log.e(TAG, String.format(&quot;Could not fetch tile %d/%d/%d.png. The URL '%s' is malformed!&quot;, levelOfDetail, x, y, urlString));</span>
<span class="nc" id="L156">					Log.e(TAG, e.getLocalizedMessage());</span>
<span class="nc" id="L157">				} catch (IOException e) {</span>
<span class="nc" id="L158">					Log.e(TAG, String.format(&quot;Could not fetch tile %d/%d/%d.png. IOException while reading from '%s'!&quot;, levelOfDetail, x, y, urlString));</span>
<span class="nc" id="L159">					Log.e(TAG, e.getLocalizedMessage());</span>
<span class="nc" id="L160">				} catch (OutOfMemoryError e) {</span>
<span class="nc" id="L161">					Log.e(TAG, &quot;Out of Memory! Clearing cache...&quot;);</span>
<span class="nc" id="L162">					Log.e(TAG, e.toString());</span>
<span class="nc" id="L163">					cache.evictAll();</span>
<span class="nc" id="L164">					System.gc();</span>
<span class="nc" id="L165">				} catch (NullPointerException e){</span>
<span class="nc" id="L166">					Log.e(TAG, &quot;Try to cache Null Pointer!&quot;);</span>
<span class="nc" id="L167">					Log.e(TAG, e.toString());</span>
				}
			}
<span class="nc" id="L170">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.3.201306030806</span>walkaround-tests (16.08.2013 02:31:21)</div></body></html>